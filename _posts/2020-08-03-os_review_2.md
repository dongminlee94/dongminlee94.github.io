---
title: "OS Review 2"
toc: true
toc_sticky: true
categories:
  - CS
---

## Outline

- 컴퓨터 시스템의 동작 원리
- 프로그램의 구조와 실행

---

## 1. 컴퓨터 시스템의 동작 원리

### 1.1 컴퓨터 시스템의 구조

- 컴퓨터 내부장치: CPU, 메모리
- 컴퓨터 외부장치: 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등
- 입출력 (Input-Output: I/O)
  - 예: 내부에서 어떤 연산 후, 디스크에 저장
- 각 하드웨어 장치에는 컨트롤러가 존재
- 커널 (Kernel): 운영체제 중 항상 메모리에 올라가 있는 부분

### 1.2 CPU 연산과 I/O 연산

- 로컬버퍼 (Local buffer): 컨트롤러 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
- 로컬버퍼로 읽어오는 작업이 끝났는지를 장치 컨트롤러가 인터럽트를 발생시켜 CPU에 보고
- CPU는 인터럽트 라인 (interrupt line)에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 먼저 처리

### 1.3 인터럽트의 일반적 기능

- 인터럽트 처리루틴 (인터럽트 핸들러): 운영체제 커널 내에 있고 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의
- 수행하는 일은 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해두는 일
- 인터럽트의 종류: 하드웨어 인터럽트, 소프트웨어 인터럽트
- 공통점: CPU는 하던 일을 멈추고 운영체제 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게됨
- 소프트웨어 인터럽트: 트랩 (trap)
  - 예외상황 (exception): 비정상적인 작업을 시도하거나 권한이 없는 작업을 시도할 때 이에 대한 처리를 위해 발생
  - 시스템 콜 (system call): 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법

### 1.4 인터럽트 핸들링

- 인터럽트 핸들링 (Interrupt handling): 인터럽트가 발생한 경우에 처리해야 할 일의 절차
- 프로세스 제어블록 (Process Control Block: PCB): 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 저장
- 프로그램 실행중 -> 인터럽트 발생 -> 프로그램 실행 상태를 PCB에 저장 -> 인터럽트 핸들링 진행 -> PCB로부터 CPU상에 복원 -> 다시 프로그램 실행
- 오늘날의 컴퓨터에서 운영체제는 인터럽트가 발생할 때에만 실행됨

### 1.5 입출력 구조

- 입출력 (I/O) 방식: 동기식 입출력 (synchronous I/O), 비동기식 입출력 (asynchronous I/O)
- 동기식 입출력
  - 입출력 요청을 했을 때 입출력 작업이 완료된 후에야 후속 작업을 수행할 수 있는 방식
  - 입출력이 완료될 때까지 CPU의 자원을 낭비
  - 해결 방법
    - CPU를 다른 프로그램에 이양해 계속 일할 수 있도록 관리함
    - 봉쇄 상태 (Blocked state)의 프로그램에게는 CPU를 할당하지 않고 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당
    - 입출력 요청의 동기화를 위해 장치마다 큐 (queue)를 두어 입출력을 요청한 순서대로 처리
- 비동기식 입출력
  - 입출력 요청을 했을 때 입출력 작업이 완료되기 전에 CPU의 제어권을 입출력 연산을 호출한 또 다른 프로그램에게 곧바로 부여하는 방식
  - 입출력과 관련 없이 수행할 수 있는 일을 하고, 입출력이 반드시 있어야 수행할 수 있는 일들은 입출력 후에 수행함
  - 처리 가능한 작업부터 처리
- 일반적으로 동기식 입출력을 사용

### 1.6 DMA

- 원칙적으로 메모리는 CU에 의해서만 접근할 수 있음
- DMA (Direct Memory Access): CPU 사용의 비효율성을 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치
- CPU가 입출력 장비들의 메모리 접근 요청에 의해 인터럽트 당하는 것을 막아줌
- DMA가 대행함으로써 CPU는 원래 하던 작업을 멈추고 인터럽트 처리할 필요가 없어짐

### 1.7 저장장치의 구조

- 저장장치
  - 주기억장치: RAM (휘발성)
  - 보조기억장치: 마그네틱 디스크 (비휘발성)
- 보조기억장치의 용도
  - 파일 시스템
  - 스왑 영역: 메모리 공간이 부족할 경우, 필요한 부분만 메모리에 올려놓고 필요하지 않은 부분은 디스크의 스왑 영역에 놓음
    - 스왑 아웃: 디스크에 내려놓는 일
    - 메모리의 연장 공간으로서의 역할

### 1.8 저장장치의 계층 구조

- 저장장치 계층
  - Primary (휘발성 저장장치): 레지스터 > 캐시 메모리 > RAM
  - Secondary (비휘발성 저장장치): 마그네틱 디스크 > 광디스크 > 마그네틱 테이프
- 상위 저장장치 계층으로 갈수록 접근 속도가 빠르지만 용량이 적어짐
- 캐싱 기업: 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저정장치의 성능을 향상시키는 총체적 기법

### 1.9 하드웨어의 보안

- 커널 모드 (Kernel mode): 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드
- 사용자 모드 (User mode): 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행
- 중요한 연산들은 커널 모드, 일반적인 연산들은 사용자 모드
- 모드비트 (Mode bit): CPU 내부에 두어 사용자 프로그램을 감시. 0이면 커널모드 1이면 사용자모드

### 1.10 메모리 보안

- 기준 레지스터 (Base register): 프로그램이 수행되는 동안 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소를 보관
- 한계 레지스터 (Limit register): 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관
- 사용자 프로그램은 기준 레지스터에 있는 주소 ~ 기준 레지스터 + 한계 레지스터값 사이의 주소 영역에만 접근 가능 (사용자 모드)
- 이 범위 안에 없으면 예외상황이라는 인터럽트 발생 -> 운영체제가 프로그램 강제 종료
- 페이징 (Paging) 기법: 하나의 프로그램이 메모리의 여러 영역에 나뉘어 위치하는 다양한 메모리 관리 기법 (커널 모드)

### 1.11 CPU 보호

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 타이머 (timer)라는 하드웨어를 사용
- 프로그램 실행 -> 타이머에 의해 정해진 시간 초과 -> 인터럽트 발생 -> 운영체제가 CPU의 제어권 획득 -> 다른 프로그램에게 CPU를 이양
- 매 클럭 틱 (clock tick)마다 1씩 감소, 0이 되면 인터럽트

### 1.12 시스템 콜을 이용한 입출력 수행

- 시스템 콜의 예
  - 사용자 프로그램이 디스크의 파일에 있는 데이터를 쓰는 것
  - 사용자 프로그램이 디스크의 파일로부터 데이터를 읽는 것
  - 키보드로부터 입력을 받는 것
  - 수행 결과를 화면에 출력하는 것

---

## 2. 프로그램의 구조와 실행

### 2.1 프로그램의 구조

- 프로그램의 주소 영역
  - 코드 (Code) 영역: 작성한 프로그램 함수들의 코드가 저장되는 영역
  - 데이터 (Data) 영역: 전역 변수, 정적 변수 등 프로그램이 사용하는 데이터를 저장하는 영역
  - 스택 (Stack) 영역: 함수가 호출될 때 함수의 수행을 마치고 복귀할 값 (지역 변수, 매개변수, 리턴값 등)를 임시로 저장하는 영역

### 2.2 컴퓨터 시스템의 작동 개요

- 프로그램 카운터 (Program Counter: PC): CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터
- CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리
- CPU가 수행하는 명령
  - 일반명령: 모든 프로그램이 수행할 수 있는 명령. 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들
  - 특권명령: 보안이 필요한 명령. 입출력 장치나 타이머 등 각종 장치에 접근하는 명령. 운영체제만이 수행 가능
  - CPU 내에 모드비트를 두어서 실행가능성을 체크
- 사용자 프로그램이 운영체제에게 특권명령의 대행을 요청하는 것이 시스템 콜

### 2.3 프로그램의 실행

- '프로그램이 실행 (program execution)되고 있다'
  - 디스크에 존재하던 실행파일이 메모리에 적재
  - 프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태
- 운영체제 커널의 주소 영역
  - 코드
    - CPU, 메모리 등의 자원을 관리하기 위한 부분
    - 사용자에게 편리한 인터페이스를 제공하기 위한 부분
    - 시스템 콜 및 인터럽트를 처리하기 위한 부분
  - 데이터
    - CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조
    - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 PCB
  - 스택
    - 복귀할 값을 저장하기 위한 용도
    - 프로세스마다 별도의 스택을 두어 관리
- 시스템 콜이나 인터럽트 발생으로 CPU의 수행 주체가 운영체제로 바뀔 때,
  - 프로그램의 복귀 정보는 스택이 아닌 데이터에 있는 PCB를 사용
  - 함수 호출에 대한 복귀 값은 스택을 사용

### 2.4 사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수
  - 사용자 정의 함수: 프로그래머 본인이 직접 작성한 함수
  - 라이브러리 함수: 함수를 호출만 하여 사용하는 함수
- 커널 함수: 운영체제 커널의 코드에 정의된 함수
  - 시스템 콜 함수: 프로그램이 운영체제의 서비를 요청하기 위해 호출하는 함수
  - 인터럽트 처리 함수: 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 함수

### 2.5 인터럽트

- 인터러트 처리 중에 또 다른 인터럽트가 발생하는 경우
  - 원칙적으로는 또 다른 인터럽트가 발생하는 것을 허용하지 않음 (데이터의 일관성이 유지되지 않음)
  - 따라서 우선순위를 두고 우선순위가 높은 인터럽트를 처리

### 2.6 시스템 콜

- 사용자 프로그램이 중간에 CPU를 빼앗기는 경우
  - 타이머에 의해 인터럽트가 발생하는 경우: 독점 방지
  - 입출력 요청을 위해 시스템 콜을 하는 경우: 시간이 오래 걸리는 입출력 작업으로 인해 CPU를 다른 프로세스에게 이양

### 2.7 프로세스의 두 가지 실행 상태

- 사용자 모드: 사용자 정의 함수나 라이브러리 함수를 호출
- 커널 모드: 시스템 콜
